Go to your Supabase dashboard.
Navigate to the Table Editor and click Create a new table.
Name the table profiles.
Add the following columns:
id (uuid, Primary Key, references auth.users via a foreign key).
email (text).
role (text, with a default value of 'user'). 
Step 2: Create a Postgres function to set the role
This function will automatically insert a record into the profiles table when a new user signs up.
Go to the SQL Editor in your Supabase dashboard.
Paste and run the following SQL code:
sql
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role)
  values (new.id, new.email, 'user');
  return new;
end;
$$ language plpgsql security definer;
Use code with caution.

Create a trigger on the auth.users table that calls this function. Run the following SQL:
sql
create or replace trigger on_auth_user_created
after insert on auth.users
for each row execute function public.handle_new_user();
Use code with caution.

 
Step 3: Manually update the role for your two admin users
In the Supabase Table Editor, find the two admin users and manually change their role from 'user' to 'admin' in the profiles table.
Step 4: Update your Next.js middleware
Now, modify your middleware.ts file to check for the admin role.
typescript
import { type NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  const { supabase, response } = createClient(request)

  const {
    data: { user },
  } = await supabase.auth.getUser()

  const { pathname } = request.nextUrl

  // Fetch the user's role from the 'profiles' table
  let userIsAdmin = false
  if (user) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()
    userIsAdmin = profile?.role === 'admin'
  }

  // --- Main Logic ---

  // Redirect logged-in non-admins and logged-out users from the admin dashboard
  if (pathname.startsWith('/admin')) {
    if (!userIsAdmin) {
      return NextResponse.redirect(new URL('/login', request.url))
    }
  }

  // Redirect logged-in admins from the login page
  if (pathname === '/login' && userIsAdmin) {
    return NextResponse.redirect(new URL('/admin', request.url))
  }

  // Handle all other cases
  return response
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
}
Use code with caution.

Why this approach fixes your issue
The updated middleware performs a crucial authorization check:
It first fetches the authenticated user's session, just as before.
It then makes a second, explicit database query to your profiles table to retrieve the role for that specific user.
The userIsAdmin boolean is then used to enforce a much more precise authorization rule: only users with the admin role can access the /admin routes. 
This is more secure than relying on client-side checks and prevents regular users from accessing your admin pages, even if they somehow obtain a session cookie.
AI responses may include mistakes. Learn more




Show me how to modify the token with custom claims

What are the security implications of storing user roles directly in the JWT?

How can I handle multiple roles per user with this setup?

undefined


